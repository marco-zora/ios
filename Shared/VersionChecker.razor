@inject HttpClient Http
@inject NavigationManager Nav
@implements IAsyncDisposable
@inject IJSRuntime JS

@if (updateAvailable)
{
    <div class="update-banner" @onclick="ApplyUpdate">
        È disponibile una nuova versione — clicca per aggiornare
    </div>
}

@code {
    private string? currentVersion;
    private bool updateAvailable;
    private PeriodicTimer? timer;
    private CancellationTokenSource? cts;

    protected override async Task OnInitializedAsync()
    {
        // prima lettura
        currentVersion = await LoadVersion();

        // avvia polling ogni 15s
        cts = new CancellationTokenSource();
        timer = new PeriodicTimer(TimeSpan.FromSeconds(15));
        _ = PollAsync(cts.Token);   // avvio “in background” controllato
    }

    private async Task PollAsync(CancellationToken token)
    {
        if (timer is null) return;

        try
        {
            while (await timer.WaitForNextTickAsync(token))
            {
                var latest = await LoadVersion();
                if (!string.IsNullOrWhiteSpace(latest) && latest != currentVersion)
                {
                    updateAvailable = true;
                    await InvokeAsync(StateHasChanged);
                    break; // smetti di pollare: una nuova versione è disponibile
                }
            }
        }
        catch (OperationCanceledException)
        {
            // ignorata alla Dispose
        }
    }

    private async Task<string?> LoadVersion()
    {
        try
        {
            // cache-busting per evitare risposte dalla cache SW
            var ts = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
            return await Http.GetStringAsync($"version.json?ts={ts}");
        }
        catch
        {
            return null;
        }
    }

    //private void ApplyUpdate()
    private async Task ApplyUpdate()
    {
        // ricarica forzando il download della nuova versione
        //Nav.NavigateTo(Nav.Uri, forceLoad: true);
        await JS.InvokeVoidAsync("forceHardReload");
    }

    public async ValueTask DisposeAsync()
    {
        cts?.Cancel();
        timer?.Dispose();
        cts?.Dispose();
        await Task.CompletedTask;
    }
}